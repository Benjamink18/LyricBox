# LyricBox Database Architecture

**Last Updated:** December 4, 2025  
**Status:** Normalized Multi-Table Structure

---

## Overview

LyricBox uses a **normalized multi-table database** in Supabase with 7 tables linked by `song_id`:

1. **songs** - Master table with core identity and metadata
2. **song_metadata** - Musixmatch/MusicBrainz enrichment data
3. **song_lyrics** - Lyrics text per section
4. **song_chords** - Ultimate Guitar chord data (6 versions per section)
5. **song_rhyme_analysis** - Claude AI rhyme schemes per section  
6. **song_concepts** - Claude AI themes and concepts
7. **song_youtube_data** - YouTube transcripts and comments

All tables are linked by **`song_id`** (UUID, auto-generated by Supabase).

---

## Table Structures

### 1. `songs` (Master Table)

**Purpose:** Core song identity from Billboard CSV + basic metadata

```sql
CREATE TABLE songs (
  song_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  track_name TEXT NOT NULL,
  artist_name TEXT NOT NULL,
  peak_position INTEGER,
  
  -- Metadata from Musixmatch/MusicBrainz
  bpm INTEGER,
  musical_key TEXT,
  genres TEXT[],
  moods TEXT[],
  release_date DATE,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  UNIQUE(artist_name, track_name)  -- No duplicate songs
);
```

**Key Points:**
- `song_id` is auto-generated UUID
- `UNIQUE` constraint on artist + track prevents duplicates
- Song enters database ONLY if metadata AND lyrics are found
- If UG chords found, `musical_key` updated with UG tonality

---

### 2. `song_metadata` (DEPRECATED - Merged into songs table)

**Note:** Metadata fields now in `songs` table directly.

---

### 3. `song_lyrics` (Lyrics Per Section)

**Purpose:** Store lyrics by section (from Genius or other sources)

```sql
CREATE TABLE song_lyrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  song_id UUID REFERENCES songs(song_id) ON DELETE CASCADE,
  section_name TEXT NOT NULL,  -- "Verse 1", "Chorus", etc.
  lyrics_text TEXT NOT NULL,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_lyrics_song_id ON song_lyrics(song_id);
```

**Example Data:**
| song_id | section_name | lyrics_text |
|---------|-------------|-------------|
| uuid-1  | Verse 1     | I'm going under... |
| uuid-1  | Chorus      | I need somebody... |

---

### 4. `song_chords` (Chords Per Section - 6 Versions)

**Purpose:** Ultimate Guitar chord data with 6 representations per section

```sql
CREATE TABLE song_chords (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  song_id UUID REFERENCES songs(song_id) ON DELETE CASCADE,
  section_name TEXT NOT NULL,  -- "Intro", "Verse 1", "Chorus", etc.
  tonality TEXT,               -- Musical key from UG (e.g., "G", "Am")
  
  -- 6 chord versions (TEXT[] arrays)
  chords_original TEXT[],
  chords_original_simplified TEXT[],
  chords_transposed_c TEXT[],
  chords_transposed_c_simplified TEXT[],
  chords_roman TEXT[],
  chords_roman_simplified TEXT[],
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_chords_song_id ON song_chords(song_id);
CREATE INDEX idx_chords_section ON song_chords(section_name);

-- GIN indexes for array searching
CREATE INDEX idx_chords_original ON song_chords USING gin(chords_original);
CREATE INDEX idx_chords_transposed ON song_chords USING gin(chords_transposed_c);
CREATE INDEX idx_chords_roman ON song_chords USING gin(chords_roman);
```

**6 Chord Versions Explained:**
1. **original** - As scraped from UG (e.g., `["G", "Cadd9", "Asus4"]`)
2. **original_simplified** - Embellishments removed (e.g., `["G", "C", "A"]`)
3. **transposed_c** - Transposed to C major (e.g., `["C", "Fadd9", "Dsus4"]`)
4. **transposed_c_simplified** - Transposed + simplified (e.g., `["C", "F", "D"]`)
5. **roman** - Roman numerals in C (e.g., `["I", "IVadd9", "IIsus4"]`)
6. **roman_simplified** - Roman numerals simplified (e.g., `["I", "IV", "II"]`)

---

### 5. `song_rhyme_analysis` (Rhyme Schemes Per Section)

**Purpose:** Claude AI-generated rhyme schemes for each lyric section

**Status:** WORKING WELL - Keep as-is

```sql
CREATE TABLE song_rhyme_analysis (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  song_id UUID REFERENCES songs(song_id) ON DELETE CASCADE,
  section_name TEXT NOT NULL,  -- "Verse 1", "Chorus", etc.
  
  -- Rhyme data
  rhyme_scheme TEXT,           -- "AABBCCDD"
  rhyme_types JSONB,           -- Types detected (perfect, slant, internal, etc.)
  rhyme_density FLOAT,         -- 0.0 to 1.0
  notable_patterns TEXT[],     -- Interesting rhyme patterns found
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_rhyme_song_id ON song_rhyme_analysis(song_id);
CREATE INDEX idx_rhyme_types ON song_rhyme_analysis USING gin(rhyme_types);
```

**Note:** Rhyme analysis is section-aware to find complex patterns like slant, compound, internal rhymes.

---

### 6. `song_concepts` (AI Theme Analysis)

**Purpose:** Claude AI-generated themes, concepts, and imagery

**Status:** WORKING WELL - Keep as-is

```sql
CREATE TABLE song_concepts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  song_id UUID REFERENCES songs(song_id) ON DELETE CASCADE,
  
  -- Concept data
  themes TEXT[],               -- Main themes (e.g., ["love", "loss", "hope"])
  metaphors JSONB,             -- Metaphors found with explanations
  tone TEXT,                   -- Overall tone (e.g., "melancholic", "uplifting")
  imagery TEXT[],              -- Visual/sensory imagery
  story_arc TEXT,              -- Narrative structure
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_concepts_song_id ON song_concepts(song_id);
CREATE INDEX idx_concepts_themes ON song_concepts USING gin(themes);
CREATE INDEX idx_concepts_imagery ON song_concepts USING gin(imagery);
```

---

### 7. `song_youtube_data` (Real Talk Feature)

**Purpose:** YouTube transcripts and comments for "Real Talk" section

**Status:** Separate feature layer (Layer 5)

```sql
CREATE TABLE song_youtube_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  song_id UUID REFERENCES songs(song_id) ON DELETE CASCADE,
  
  -- YouTube data
  video_id TEXT,
  channel_name TEXT,
  transcript TEXT,
  top_comments JSONB,          -- Array of comment objects
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_youtube_song_id ON song_youtube_data(song_id);
```

---

## Data Flow & Enrichment Pipeline

### Layer 1: Master CSV Import
- **Input:** `master_songs_2020_2025_billboard_consolidated.csv`
- **Contains:** `track_name`, `artist_name`, `peak_position`

### Layer 2: Metadata Enrichment
- **Source 1:** Musixmatch API (`get_track_data.py`)
- **Source 2:** MusicBrainz API (fallback)
- **Fetches:** BPM, musical_key, genres, moods, release_date
- **Rule:** Song ONLY added to database if metadata found
- **Logging:** `metadata_not_found.txt` for failures

### Layer 3: Lyrics Enrichment
- **Source 1:** Genius.com (Playwright scraper - `genius_scrape/`)
- **Source 2:** Lyrics.ovh (fallback)
- **Source 3:** LRCLIB (fallback)
- **Fetches:** Lyrics with section markers (`[Verse 1]`, `[Chorus]`, etc.)
- **Rule:** Song ONLY added if lyrics found (even if metadata partial)
- **Logging:** `lyrics_not_found.txt` for failures

### Layer 4: Chord Enrichment
- **Source:** Ultimate Guitar (Playwright scraper - `ug_scraper/`)
- **Fetches:** Chords per section + tonality
- **Processing:** 6 chord versions generated
- **Optional:** Song can exist without chords
- **Logging:** `chords_not_found.txt` if no official tab
- **Tonality Rule:** If UG tonality found, update `songs.musical_key`

### Layer 5: AI Analysis (Rhyme + Concepts)
- **Source:** Claude AI (Anthropic API)
- **Fetches:** Rhyme schemes + thematic concepts
- **Status:** WORKING WELL - formalized as part of core pipeline

### Layer 6: YouTube Data (Real Talk)
- **Source:** YouTube (separate feature)
- **Status:** Additional layer, not required for song entry

---

## Database Entry Rules

### Songs Enter Database IF:
✅ **Metadata found** (Musixmatch OR MusicBrainz)  
✅ **Lyrics found** (Genius OR Lyrics.ovh OR LRCLIB)

### Songs Do NOT Enter IF:
❌ No metadata from any source → Log to `metadata_not_found.txt`  
❌ Metadata found but no lyrics → Log to `lyrics_not_found.txt`

### Optional Data:
- ✨ Chords (nice-to-have, logged if missing)
- ✨ YouTube data (separate "Real Talk" feature)

---

## Key Architectural Decisions

### 1. Normalized Structure
- **Why:** Allows flexible querying (e.g., search chords without loading full lyrics)
- **Trade-off:** More complex JOIN queries
- **Benefit:** Clean separation of concerns, easier updates

### 2. `song_id` as UUID
- **Generated by:** Supabase on INSERT into `songs` table
- **Rule:** One song = one ID (enforced by UNIQUE constraint on artist + track)
- **Cascade:** `ON DELETE CASCADE` on all foreign keys

### 3. Section-Based Storage
- **Lyrics:** One row per section in `song_lyrics`
- **Chords:** One row per section in `song_chords`
- **Rhymes:** One row per section in `song_rhyme_analysis`
- **Why:** Enables section-specific analysis and search

### 4. Array Types for Chords
- **Type:** `TEXT[]` (PostgreSQL array)
- **Benefit:** Native array operations, GIN indexing
- **Search:** Can query "find songs with chord progression [I, IV, V]"

### 5. JSONB for Complex Data
- **Used in:** `metaphors`, `top_comments`, `rhyme_types`
- **Benefit:** Flexible structure, queryable with PostgreSQL JSON functions

---

## Full Documentation
For complete details, see:
- Data flow: `/backend/data_enrichment/DATA_FLOW_EXPLANATION.md`
- Existing database: `/HANDOVER_DATABASE.md` (older structure)
- Rhyme types: `/backend/Rhyme Research Folder/RHYME_TYPES_REFERENCE.md`

---

**Last Updated:** December 4, 2025

