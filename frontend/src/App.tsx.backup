import { useState, useEffect } from 'react'
import { 
  searchRhymes,
  searchRhymeNetworkByDepth,
  prepareResultsForSorting,
  applySorting,
  getSongStats, 
  getDistinctGenres, 
  getDistinctYears,
  getRandomConcept,
  generateCustomConcept,
  getSongLyrics,
  supabase,
  type SimpleRhymeResult,
  type ConceptWithSong,
  type Concept,
  type RhymeNetworkFilters as RhymeNetworkFiltersType,
  type SortCriterion,
  type SortableRhymeResult,
  type RhymeNetworkResult
} from './lib/supabase'
import { SortBuilder } from './components/SortBuilder'
import { FilterSidebar } from './components/FilterSidebar'
import './App.css'

type Page = 'rhymes' | 'figurative' | 'concepts' | 'nextline'
type SearchMode = 'simple' | 'network'

function App() {
  const [currentPage, setCurrentPage] = useState<Page>('rhymes')
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)
  const [searchMode, setSearchMode] = useState<SearchMode>('simple')
  const [filterSidebarOpen, setFilterSidebarOpen] = useState(false)
  
  // Search state
  const [query, setQuery] = useState('')
  const [loading, setLoading] = useState(false)
  const [stats, setStats] = useState({ songs: 0, lines: 0 })
  const [searched, setSearched] = useState(false)
  
  // Simple search state
  const [unfilteredSimpleResults, setUnfilteredSimpleResults] = useState<SimpleRhymeResult[]>([])
  const [simpleResults, setSimpleResults] = useState<SimpleRhymeResult[]>([])
  const [onePerSong, setOnePerSong] = useState(true)
  
  // Network search state
  const [networkResult, setNetworkResult] = useState<RhymeNetworkResult | null>(null)
  const [unfilteredResults, setUnfilteredResults] = useState<SortableRhymeResult[]>([])
  const [sortedResults, setSortedResults] = useState<SortableRhymeResult[]>([])
  const [sortOrder, setSortOrder] = useState<SortCriterion[]>([])
  const [maxDepth, setMaxDepth] = useState(3)
  const [expandedWords, setExpandedWords] = useState<Set<string>>(new Set())
  
  // Unified filters for both modes
  const [filters, setFilters] = useState<RhymeNetworkFiltersType>({})
  
  // Concepts page state
  const [concept, setConcept] = useState<ConceptWithSong | null>(null)
  const [titles, setTitles] = useState<string[]>([])
  const [conceptLoading, setConceptLoading] = useState(false)
  const [generatingTitles, setGeneratingTitles] = useState(false)
  const [referenceSongs, setReferenceSongs] = useState<string[]>([])
  const [conceptMode, setConceptMode] = useState<'random' | 'custom'>('random')
  const [customIdea, setCustomIdea] = useState('')
  const [conceptFilters, setConceptFilters] = useState({
    numSongs: 10,
    years: [] as number[],
    minRank: undefined as number | undefined,
    maxRank: undefined as number | undefined,
    genres: [] as string[],
    artists: [] as string[]
  })
  const [matchedSongs, setMatchedSongs] = useState<Array<{id: string, title: string, artist: string, rank: number | null, themes: string[], matchScore?: number, imagery?: string[], tone?: string, universal_scenarios?: string[]}>>([])
  const [extractedThemes, setExtractedThemes] = useState<string[]>([])
  const [viewingSongDetails, setViewingSongDetails] = useState<string | null>(null)
  const [songSearchQuery, setSongSearchQuery] = useState('')
  const [songSearchResults, setSongSearchResults] = useState<Array<{id: string, title: string, artist: string}>>([])
  const [showingSongMatches, setShowingSongMatches] = useState(false)
  
  // Next Line state
  const [nextLineConcept, setNextLineConcept] = useState('')
  const [existingLyrics, setExistingLyrics] = useState('')
  const [exampleLine, setExampleLine] = useState('')
  const [rhymeTarget, setRhymeTarget] = useState('')
  const [rhymePosition, setRhymePosition] = useState<'end' | 'internal'>('end')
  const [rhymeTypeFilter, setRhymeTypeFilter] = useState<string>('any')
  const [lineMeaning, setLineMeaning] = useState('')
  const [specificRhymeWord, setSpecificRhymeWord] = useState('')
  const [partialLine, setPartialLine] = useState('')
  const [lineType, setLineType] = useState<'regular' | 'metaphor' | 'simile'>('regular')
  const [nextLineMatchedSongs, setNextLineMatchedSongs] = useState<Array<{id: string, title: string, artist: string, rank: number | null, themes?: string[], matchScore?: number, imagery?: string[], tone?: string, universal_scenarios?: string[]}>>([])
  const [nextLineExtractedThemes, setNextLineExtractedThemes] = useState<string[]>([])
  const [viewingNextLineSongDetails, setViewingNextLineSongDetails] = useState<string | null>(null)
  const [showingNextLineSongs, setShowingNextLineSongs] = useState(false)
  const [nextLineSuggestions, setNextLineSuggestions] = useState<Array<{line: string, syllables: number, diff: number}>>([])

  const [generatingNextLine, setGeneratingNextLine] = useState(false)
  const [nextLineFilters, setNextLineFilters] = useState({
    numSongs: 10,
    years: [] as number[],
    minRank: undefined as number | undefined,
    maxRank: undefined as number | undefined,
    genres: [] as string[],
    artists: [] as string[]
  })

  // Figurative Language Finder state
  const [figurativeKeywords, setFigurativeKeywords] = useState<string[]>(['like'])
  const [figurativeResults, setFigurativeResults] = useState<Array<{
    songId: string,
    songTitle: string,
    artist: string,
    line: string,
    lineNumber: number,
    context: string[],
    keyword: string
  }>>([])
  const [figurativeSearching, setFigurativeSearching] = useState(false)
  const [figurativeCustomKeyword, setFigurativeCustomKeyword] = useState('')
  const [figurativeGenerating, setFigurativeGenerating] = useState(false)
  const [figurativeMeaning, setFigurativeMeaning] = useState('')
  const [figurativeFilters, setFigurativeFilters] = useState({
    years: [] as number[],
    minRank: undefined as number | undefined,
    maxRank: undefined as number | undefined,
    genres: [] as string[],
    artists: [] as string[]
  })
  
  // Lyrics modal
  const [showLyricsModal, setShowLyricsModal] = useState(false)
  const [modalLyrics, setModalLyrics] = useState('')
  const [modalSongTitle, setModalSongTitle] = useState('')
  const [modalHighlightWords, setModalHighlightWords] = useState<string[]>([])
  const [modalViewMode, setModalViewMode] = useState<'context' | 'full'>('full')

  useEffect(() => {
    getSongStats().then(setStats)
  }, [])

  // Apply filters client-side for Simple search
  const applySimpleFilters = (results: SimpleRhymeResult[]): SimpleRhymeResult[] => {
    let filtered = [...results]
    
    // Genre filter
    if (filters.genres && filters.genres.length > 0) {
      filtered = filtered.filter(r => filters.genres!.includes(r.song.genre || ''))
    }
    
    // Year filter
    if (filters.years && filters.years.length > 0) {
      filtered = filtered.filter(r => filters.years!.includes(r.song.year || 0))
    }
    
    // Billboard rank filter
    if (filters.minRank !== undefined) {
      filtered = filtered.filter(r => (r.song.billboard_rank || 999) >= filters.minRank!)
    }
    if (filters.maxRank !== undefined) {
      filtered = filtered.filter(r => (r.song.billboard_rank || 999) <= filters.maxRank!)
    }
    
    return filtered
  }

  // Apply filters client-side for Network search
  const applyNetworkFilters = (results: SortableRhymeResult[]): SortableRhymeResult[] => {
    let filtered = [...results]
    
    // Depth filter
    if (filters.depths && filters.depths.length > 0) {
      filtered = filtered.filter(r => filters.depths!.includes(r.depth))
    }
    
    // Rhyme type filter
    if (filters.rhymeTypes && filters.rhymeTypes.length > 0) {
      filtered = filtered.filter(r => filters.rhymeTypes!.includes(r.rhymeType))
    }
    
    // Genre filter
    if (filters.genres && filters.genres.length > 0) {
      filtered = filtered.filter(r => 
        r.connections.some(c => filters.genres!.includes(c.song.genre || ''))
      )
    }
    
    // Year filter
    if (filters.years && filters.years.length > 0) {
      filtered = filtered.filter(r =>
        r.connections.some(c => filters.years!.includes(c.song.year || 0))
      )
    }
    
    // Billboard rank filter
    if (filters.minRank !== undefined || filters.maxRank !== undefined) {
      filtered = filtered.filter(r =>
        r.connections.some(c => {
          const rank = c.song.billboard_rank || 999
          const minOk = filters.minRank === undefined || rank >= filters.minRank
          const maxOk = filters.maxRank === undefined || rank <= filters.maxRank
          return minOk && maxOk
        })
      )
    }
    
    return filtered
  }

  // Re-sort network results when sort order changes
  // Re-run Simple search when onePerSong changes
  useEffect(() => {
    if (searched && query.trim() && searchMode === 'simple') {
      const runSearch = async () => {
        setLoading(true)
        try {
          const showAll = !onePerSong // Invert: checked = 1 per song, unchecked = all
          const data = await searchRhymes(query.trim(), {}, showAll)
          setUnfilteredSimpleResults(data)
          const filtered = applySimpleFilters(data)
          setSimpleResults(filtered)
        } catch (err) {
          console.error('Search failed:', err)
        } finally {
          setLoading(false)
        }
      }
      runSearch()
    }
  }, [onePerSong])

  // Re-process Simple search results when filters change (client-side, fast!)
  useEffect(() => {
    if (unfilteredSimpleResults.length > 0 && searchMode === 'simple') {
      const filtered = applySimpleFilters(unfilteredSimpleResults)
      setSimpleResults(filtered)
    }
  }, [filters, unfilteredSimpleResults, searchMode])

  // Re-process Network results when filters or sort order change (client-side, fast!)
  useEffect(() => {
    if (unfilteredResults.length > 0 && searchMode === 'network') {
      const filtered = applyNetworkFilters(unfilteredResults)
      const sorted = sortOrder.length > 0 ? applySorting(filtered, sortOrder) : filtered
      setSortedResults(sorted)
    }
  }, [filters, sortOrder, unfilteredResults, searchMode])

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!query.trim()) return

    setLoading(true)
    setSearched(true)
    
    try {
      if (searchMode === 'simple') {
        // Simple search - fetch all, filter client-side
        const showAll = !onePerSong // Invert: checked = 1 per song, unchecked = all
        const data = await searchRhymes(query.trim(), {}, showAll)
        setUnfilteredSimpleResults(data)
        
        // Apply filters client-side
        const filtered = applySimpleFilters(data)
        setSimpleResults(filtered)
        setNetworkResult(null)
        setUnfilteredResults([])
      } else {
        // Network search - depth-based (no filters in query - we filter client-side!)
        const result = await searchRhymeNetworkByDepth(query.trim(), maxDepth, {})
        setNetworkResult(result)
        
        // Store unfiltered results
        const sortable = prepareResultsForSorting(result)
        setUnfilteredResults(sortable)
        
        // Apply filters and sorting client-side
        const filtered = applyFilters(sortable)
        const sorted = sortOrder.length > 0 ? applySorting(filtered, sortOrder) : filtered
        setSortedResults(sorted)
        setSimpleResults([])
      }
    } catch (err) {
      console.error('Search failed:', err)
    } finally {
      setLoading(false)
    }
  }

  const handleViewLyrics = async (songId: string, title: string, artist: string, highlightWords?: string[]) => {
    const lyrics = await getSongLyrics(songId)
    if (lyrics) {
      setModalLyrics(lyrics)
      setModalSongTitle(`${title} - ${artist}`)
      setModalHighlightWords(highlightWords || [])
      setModalViewMode(highlightWords && highlightWords.length > 0 ? 'context' : 'full')
      setShowLyricsModal(true)
    }
  }
  
  const getContextView = (lyrics: string, searchWords: string[]) => {
    const lines = lyrics.split('\n')
    const contexts: Array<{linesBefore: string[], matchLine: string, linesAfter: string[], lineNumber: number}> = []
    
    // Find all lines containing any of the search words
    lines.forEach((line, index) => {
      const trimmedLine = line.trim()
      if (!trimmedLine) return
      
      // Check if line contains any of the search words
      const hasMatch = searchWords.some(word => 
        trimmedLine.toLowerCase().includes(word.toLowerCase())
      )
      
      if (hasMatch) {
        // Get 4 non-empty lines before and after
        const linesBefore: string[] = []
        const linesAfter: string[] = []
        
        let beforeIndex = index - 1
        while (linesBefore.length < 4 && beforeIndex >= 0) {
          const beforeLine = lines[beforeIndex].trim()
          if (beforeLine) linesBefore.unshift(beforeLine)
          beforeIndex--
        }
        
        let afterIndex = index + 1
        while (linesAfter.length < 4 && afterIndex < lines.length) {
          const afterLine = lines[afterIndex].trim()
          if (afterLine) linesAfter.push(afterLine)
          afterIndex++
        }
        
        contexts.push({
          linesBefore,
          matchLine: trimmedLine,
          linesAfter,
          lineNumber: index + 1
        })
      }
    })
    
    return contexts
  }
  
  const toggleExpanded = (word: string) => {
    setExpandedWords(prev => {
      const newSet = new Set(prev)
      if (newSet.has(word)) {
        newSet.delete(word)
      } else {
        newSet.add(word)
      }
      return newSet
    })
  }

  const activeFilterCount = 
    (filters.rhymeTypes?.length || 0) +
    (filters.genres?.length || 0) +
    (filters.years?.length || 0) +
    (filters.depths?.length || 0)

  const handleGenerateConcept = async () => {
    if (conceptMode === 'random') {
      setConceptLoading(true)
      try {
      const randomConcept = await getRandomConcept()
      if (randomConcept) {
        setConcept(randomConcept)
        setTitles(randomConcept.alternative_titles || [])
        // For random concepts, use the source song as reference
        if (randomConcept.songs) {
          setReferenceSongs([`${randomConcept.songs.title} - ${randomConcept.songs.artist}`])
        }
      }
      } catch (err) {
        console.error('Failed to generate concept:', err)
      } finally {
        setConceptLoading(false)
      }
    } else {
      // Custom concept generation
      if (!customIdea.trim()) {
        alert('Please enter your concept idea')
        return
      }
      setConceptLoading(true)
      try {
        const customConcept = await generateCustomConcept(
          customIdea,
          conceptFilters.numSongs,
          {
            years: conceptFilters.years.length > 0 ? conceptFilters.years : undefined,
            minRank: conceptFilters.minRank,
            maxRank: conceptFilters.maxRank,
            genres: conceptFilters.genres.length > 0 ? conceptFilters.genres : undefined,
            artists: conceptFilters.artists.length > 0 ? conceptFilters.artists : undefined
          },
          matchedSongs.length > 0 ? matchedSongs.map(s => s.id) : undefined
        )
        
        if (customConcept) {
          // Convert to ConceptWithSong format for display
          const conceptWithSong: ConceptWithSong = {
            ...customConcept,
            id: 'custom',
            song_id: 'custom',
            songs: {
              id: 'custom',
              title: 'Custom Concept',
              artist: 'Generated',
              year: new Date().getFullYear(),
              billboard_rank: null,
              genre: null
            }
          }
          setConcept(conceptWithSong)
          setTitles(customConcept.alternative_titles || [])
          
          // Store reference songs for generating more titles later
          if (customConcept._meta && customConcept._meta.example_songs) {
            setReferenceSongs(customConcept._meta.example_songs)
          }
        } else {
          alert('Failed to generate concept. Please try again.')
        }
      } catch (err) {
        console.error('Failed to generate custom concept:', err)
        alert('Error generating concept. Please check console for details.')
      } finally {
        setConceptLoading(false)
      }
    }
  }

  // Calculate estimated time for concept generation
  const getEstimatedTime = () => {
    if (conceptMode === 'random') return 1
    const numSongs = matchedSongs.length > 0 ? matchedSongs.length : conceptFilters.numSongs
    return 8 + (numSongs * 0.5)
  }

  // Find matching songs based on theme and filters
  const handleFindMatchingSongs = async () => {
    if (!customIdea.trim()) {
      alert('Please enter your concept idea first')
      return
    }

    setConceptLoading(true)
    try {
      // Call backend to extract themes and find matches
      const response = await fetch('http://localhost:3001/api/find-matching-songs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_idea: customIdea,
          num_songs: conceptFilters.numSongs,
          filters: {
            years: conceptFilters.years.length > 0 ? conceptFilters.years : undefined,
            minRank: conceptFilters.minRank,
            maxRank: conceptFilters.maxRank,
            genres: conceptFilters.genres.length > 0 ? conceptFilters.genres : undefined,
            artists: conceptFilters.artists.length > 0 ? conceptFilters.artists : undefined
          }
        })
      })

      if (response.ok) {
        const data = await response.json()
        console.log('Concepts - Received data:', data)
        setMatchedSongs(data.songs || [])
        setExtractedThemes(data.extracted_themes || [])
        setShowingSongMatches(true)
      } else {
        const errorText = await response.text()
        console.error('Server error response:', errorText)
        alert(`Failed to find matching songs: ${response.status}`)
      }
    } catch (err) {
      console.error('Error finding matching songs:', err)
      alert(`Error finding songs: ${err instanceof Error ? err.message : String(err)}`)
    } finally {
      setConceptLoading(false)
    }
  }

  // Search for songs to add manually
  const handleSearchSongs = async (query: string) => {
    if (!query.trim()) {
      setSongSearchResults([])
      return
    }

    try {
      const { data } = await supabase
        .from('songs')
        .select('id, title, artist')
        .or(`title.ilike.%${query}%,artist.ilike.%${query}%`)
        .limit(10)
        .execute()

      setSongSearchResults(data || [])
    } catch (err) {
      console.error('Error searching songs:', err)
    }
  }

  // Add a song to the matched songs list
  const handleAddSong = async (songId: string) => {
    try {
      const { data } = await supabase
        .from('song_analysis')
        .select('song_id, themes, songs(id, title, artist, billboard_rank)')
        .eq('song_id', songId)
        .single()
        .execute()

      if (data && data.songs) {
        const newSong = {
          id: data.songs.id,
          title: data.songs.title,
          artist: data.songs.artist,
          rank: data.songs.billboard_rank,
          themes: data.themes || []
        }
        setMatchedSongs([...matchedSongs, newSong])
        setSongSearchQuery('')
        setSongSearchResults([])
      }
    } catch (err) {
      console.error('Error adding song:', err)
    }
  }

  // Remove a song from the matched songs list
  const handleRemoveSong = (songId: string) => {
    setMatchedSongs(matchedSongs.filter(s => s.id !== songId))
  }

  // Count syllables in a line
  const countSyllables = (text: string): number => {
    if (!text) return 0
    text = text.toLowerCase().trim()
    text = text.replace(/[^a-z\s]/g, '')
    const words = text.split(/\s+/).filter(w => w.length > 0)
    
    let syllables = 0
    words.forEach(word => {
      // Simple syllable counting (vowel groups)
      const vowelGroups = word.match(/[aeiouy]+/g)
      syllables += vowelGroups ? vowelGroups.length : 1
      // Adjust for silent e
      if (word.endsWith('e') && word.length > 2) syllables--
      if (syllables === 0) syllables = 1
    })
    
    return syllables
  }

  // Find matching songs for next line
  const handleFindNextLineSongs = async () => {
    if (!nextLineConcept.trim()) {
      alert('Please enter your song concept')
      return
    }

    setGeneratingNextLine(true)
    try {
      // Combine concept and lyrics for better context
      const combinedContext = existingLyrics.trim() 
        ? `${nextLineConcept}\n\nLyrics so far:\n${existingLyrics}`
        : nextLineConcept

      const response = await fetch('http://localhost:3001/api/find-matching-songs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_idea: combinedContext,
          num_songs: nextLineFilters.numSongs,
          filters: {
            years: nextLineFilters.years.length > 0 ? nextLineFilters.years : undefined,
            minRank: nextLineFilters.minRank,
            maxRank: nextLineFilters.maxRank,
            genres: nextLineFilters.genres.length > 0 ? nextLineFilters.genres : undefined,
            artists: nextLineFilters.artists.length > 0 ? nextLineFilters.artists : undefined
          }
        })
      })

      if (response.ok) {
        const data = await response.json()
        console.log('Next Line - Received data:', data)
        setNextLineMatchedSongs(data.songs || [])
        setNextLineExtractedThemes(data.extracted_themes || [])
        setShowingNextLineSongs(true)
      } else {
        const errorText = await response.text()
        console.error('Server error response:', errorText)
        alert(`Failed to find matching songs: ${response.status}`)
      }
    } catch (err) {
      console.error('Error finding songs:', err)
      alert(`Error finding songs: ${err instanceof Error ? err.message : String(err)}`)
    } finally {
      setGeneratingNextLine(false)
    }
  }

  // Generate next line suggestions
  const handleGenerateNextLine = async () => {
    if (!nextLineConcept.trim() || !exampleLine.trim()) {
      alert('Please enter concept and example line')
      return
    }

    setGeneratingNextLine(true)
    try {
      const response = await fetch('http://localhost:3001/api/generate-next-line', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          concept: nextLineConcept,
          existing_lyrics: existingLyrics,
          syllable_count: countSyllables(exampleLine),
          rhyme_target: rhymeTarget,
          rhyme_position: rhymePosition,
          rhyme_type: rhymeTypeFilter !== 'any' ? rhymeTypeFilter : undefined,
          reference_song_ids: nextLineMatchedSongs.map(s => s.id),
          line_meaning: lineMeaning.trim() || undefined,
          specific_rhyme_word: specificRhymeWord.trim() || undefined,
          partial_line: partialLine.trim() || undefined,
          line_type: lineType
        })
      })

      if (response.ok) {
        const data = await response.json()
        console.log(`Got ${data.total_generated} suggestions, ${data.exact_matches} match exactly`)
        setNextLineSuggestions(data.suggestions || [])
      } else {
        alert('Failed to generate suggestions')
      }
    } catch (err) {
      console.error('Error generating next line:', err)
      alert('Error generating suggestions')
    } finally {
      setGeneratingNextLine(false)
    }
  }

  // Use a suggested line
  const handleUseSuggestion = (suggestion: string) => {
    setExistingLyrics(existingLyrics + '\n' + suggestion)
    // Keep suggestions visible so user can continue selecting
  }

  // Generate more variations of a specific line
  const handleMoreLikeThis = async (baseLine: string) => {
    setGeneratingNextLine(true)
    try {
      const response = await fetch('http://localhost:3001/api/generate-more-like-this', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          base_line: baseLine,
          concept: nextLineConcept,
          existing_lyrics: existingLyrics,
          syllable_count: countSyllables(exampleLine),
          rhyme_target: rhymeTarget,
          rhyme_position: rhymePosition,
          rhyme_type: rhymeTypeFilter !== 'any' ? rhymeTypeFilter : undefined,
          reference_song_ids: nextLineMatchedSongs.map(s => s.id),
          line_meaning: lineMeaning.trim() || undefined,
          specific_rhyme_word: specificRhymeWord.trim() || undefined,
          partial_line: partialLine.trim() || undefined,
          line_type: lineType
        })
      })

      if (response.ok) {
        const data = await response.json()
        console.log(`Got ${data.total_generated} variations, ${data.exact_matches} match exactly`)
        // Append new variations below existing suggestions
        setNextLineSuggestions(prev => [...prev, ...(data.suggestions || [])])
      } else {
        alert('Failed to generate variations')
      }
    } catch (err) {
      console.error('Error generating variations:', err)
      alert('Error generating variations')
    } finally {
      setGeneratingNextLine(false)
    }
  }

  // Search for figurative language (similes, metaphors)
  const handleFigurativeSearch = async () => {
    if (figurativeKeywords.length === 0) {
      alert('Please select at least one keyword to search for')
      return
    }

    setFigurativeSearching(true)
    setFigurativeResults([])

    try {
      // Query songs from Supabase and search lyrics for keywords
      const { data: songs, error } = await supabase
        .from('songs')
        .select('id, title, artist, lyrics, billboard_rank, genre, release_year')
      
      if (error) throw error

      const results: typeof figurativeResults = []
      
      for (const song of songs || []) {
        if (!song.lyrics) continue
        
        // Apply filters
        if (figurativeFilters.years.length > 0 && 
            (!song.release_year || !figurativeFilters.years.includes(song.release_year))) continue
        if (figurativeFilters.minRank !== undefined && 
            (song.billboard_rank === null || song.billboard_rank > figurativeFilters.minRank)) continue
        if (figurativeFilters.maxRank !== undefined && 
            (song.billboard_rank === null || song.billboard_rank < figurativeFilters.maxRank)) continue
        if (figurativeFilters.genres.length > 0 && 
            (!song.genre || !figurativeFilters.genres.some(g => song.genre?.toLowerCase().includes(g.toLowerCase())))) continue
        if (figurativeFilters.artists.length > 0 && 
            !figurativeFilters.artists.some(a => song.artist?.toLowerCase().includes(a.toLowerCase()))) continue

        const lines = song.lyrics.split('\n')
        
        lines.forEach((line, idx) => {
          const lineLower = line.toLowerCase()
          
          for (const keyword of figurativeKeywords) {
            // Check if keyword exists in line (word boundary for single words)
            const keywordLower = keyword.toLowerCase()
            const hasKeyword = keyword.includes(' ')
              ? lineLower.includes(keywordLower)  // Multi-word: simple contains
              : new RegExp(`\\b${keywordLower}\\b`).test(lineLower)  // Single word: word boundary
            
            if (hasKeyword) {
              // Get context (4 lines before and after, ignoring blank lines)
              const contextLines: string[] = []
              let beforeCount = 0
              for (let i = idx - 1; i >= 0 && beforeCount < 4; i--) {
                if (lines[i].trim()) {
                  contextLines.unshift(lines[i])
                  beforeCount++
                }
              }
              contextLines.push(line)  // The matched line
              let afterCount = 0
              for (let i = idx + 1; i < lines.length && afterCount < 4; i++) {
                if (lines[i].trim()) {
                  contextLines.push(lines[i])
                  afterCount++
                }
              }

              results.push({
                songId: song.id,
                songTitle: song.title,
                artist: song.artist,
                line: line,
                lineNumber: idx + 1,
                context: contextLines,
                keyword: keyword
              })
              break  // Only count once per line even if multiple keywords match
            }
          }
        })
      }

      setFigurativeResults(results)
    } catch (err) {
      console.error('Error searching figurative language:', err)
      alert('Error searching for figurative language')
    } finally {
      setFigurativeSearching(false)
    }
  }

  // Generate variations of a figurative line with a new meaning
  const handleGenerateFigurativeVariations = async (originalLine: string, keyword: string) => {
    if (!figurativeMeaning.trim()) {
      alert('Please enter the meaning you want to convey')
      return
    }

    setFigurativeGenerating(true)

    try {
      const response = await fetch('http://localhost:3001/api/generate-figurative-variations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          original_line: originalLine,
          keyword: keyword,
          desired_meaning: figurativeMeaning
        })
      })

      if (response.ok) {
        const data = await response.json()
        // Display in alert for now, we can make a modal later
        alert('Generated variations:\n\n' + data.variations.join('\n\n'))
      } else {
        alert('Failed to generate variations')
      }
    } catch (err) {
      console.error('Error generating figurative variations:', err)
      alert('Error generating variations')
    } finally {
      setFigurativeGenerating(false)
    }
  }

  // Generate more titles based on the current concept
  const handleGenerateMoreTitles = async () => {
    if (!concept) return

    setGeneratingTitles(true)
    try {
      const response = await fetch('http://localhost:3001/api/generate-more-titles', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          concept: {
            concept_summary: concept.concept_summary,
            themes: concept.themes,
            imagery: concept.imagery,
            tone: concept.tone
          },
          reference_songs: referenceSongs,
          existing_titles: titles
        })
      })

      if (response.ok) {
        const data = await response.json()
        setTitles([...titles, ...data.titles])
      } else {
        alert('Failed to generate more titles')
      }
    } catch (err) {
      console.error('Error generating more titles:', err)
      alert('Error generating titles. Please try again.')
    } finally {
      setGeneratingTitles(false)
    }
  }

  return (
    <div className="app">
      {/* Sidebar */}
      <aside className={`sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}>
        <div className="sidebar-header">
          <div className="sidebar-logo" onClick={() => sidebarCollapsed && setSidebarCollapsed(false)}>
            {sidebarCollapsed ? (
              <span className="logo-letter">L</span>
            ) : (
              <h1>LyricBox</h1>
            )}
          </div>
          {!sidebarCollapsed && (
            <button 
              className="collapse-btn"
              onClick={() => setSidebarCollapsed(true)}
              title="Collapse sidebar"
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" width="16" height="16">
                <path d="M15 18l-6-6 6-6" />
              </svg>
            </button>
          )}
        </div>
        
        <nav className="sidebar-nav">
          <a 
            className={`nav-item ${currentPage === 'rhymes' ? 'active' : ''}`}
            onClick={() => setCurrentPage('rhymes')}
          >
            <svg className="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M9 18V5l12-2v13" />
              <circle cx="6" cy="18" r="3" />
              <circle cx="18" cy="16" r="3" />
            </svg>
            {!sidebarCollapsed && <span>Rhymes</span>}
          </a>

          <a 
            className={`nav-item ${currentPage === 'figurative' ? 'active' : ''}`}
            onClick={() => setCurrentPage('figurative')}
          >
            <svg className="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M12 2L2 7l10 5 10-5-10-5z" />
              <path d="M2 17l10 5 10-5" />
              <path d="M2 12l10 5 10-5" />
            </svg>
            {!sidebarCollapsed && <span>Figurative</span>}
          </a>
          
          <a 
            className={`nav-item ${currentPage === 'concepts' ? 'active' : ''}`}
            onClick={() => setCurrentPage('concepts')}
          >
            <svg className="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M9 21h6" />
              <path d="M12 17v4" />
              <path d="M12 3a6 6 0 0 0-6 6c0 2.22 1.21 4.16 3 5.2V16a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1.8c1.79-1.04 3-2.98 3-5.2a6 6 0 0 0-6-6z" />
            </svg>
            {!sidebarCollapsed && <span>Concepts</span>}
          </a>

          <a 
            className={`nav-item ${currentPage === 'nextline' ? 'active' : ''}`}
            onClick={() => setCurrentPage('nextline')}
          >
            <svg className="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <path d="M12 19l7-7 3 3-7 7-3-3z" />
              <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
              <path d="M2 2l7.586 7.586" />
            </svg>
            {!sidebarCollapsed && <span>Next Line</span>}
          </a>
        </nav>

        <div className="sidebar-footer">
          {sidebarCollapsed ? (
            <button 
              className="expand-btn"
              onClick={() => setSidebarCollapsed(false)}
              title="Expand sidebar"
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" width="16" height="16">
                <path d="M9 18l6-6-6-6" />
              </svg>
            </button>
          ) : (
            <div className="stats">
              <span>{stats.songs} songs</span>
              <span>â€¢</span>
              <span>{stats.lines.toLocaleString()} lines</span>
            </div>
          )}
        </div>
      </aside>

      {/* Main Content */}
      <main className="main-content">
        {currentPage === 'rhymes' && (
          <>
            {/* Top Bar */}
            <div className="top-bar">
              <form onSubmit={handleSearch} className="search-container">
                <input
                  type="text"
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder="Search for a word to find rhymes..."
                  className="search-input"
                />
                <button type="submit" className="search-button" disabled={loading}>
                  {loading ? 'Searching...' : 'Search'}
                </button>
              </form>
              
              <div className="top-bar-controls">
                {/* Search Mode Toggle */}
                <div className="mode-toggle">
                  <button
                    className={`mode-btn ${searchMode === 'simple' ? 'active' : ''}`}
                    onClick={() => setSearchMode('simple')}
                  >
                    Simple
                  </button>
                  <button
                    className={`mode-btn ${searchMode === 'network' ? 'active' : ''}`}
                    onClick={() => setSearchMode('network')}
                  >
                    Network
                  </button>
                </div>

                <button
                  className="filter-toggle"
                  onClick={() => setFilterSidebarOpen(true)}
                >
                  Filters {activeFilterCount > 0 && `(${activeFilterCount})`}
                </button>

                {searchMode === 'network' && (
                  <label className="depth-select">
                    Max Depth:
                    <select value={maxDepth} onChange={(e) => setMaxDepth(Number(e.target.value))}>
                      <option value={1}>1</option>
                      <option value={2}>2</option>
                      <option value={3}>3</option>
                    </select>
                  </label>
                )}
              </div>
            </div>

            {/* Network Search Sort Builder */}
            {searchMode === 'network' && networkResult && (
              <div style={{ padding: '20px', paddingTop: '0' }}>
                <SortBuilder sortOrder={sortOrder} onChange={setSortOrder} />
              </div>
            )}

            {/* Results */}
            <div className="results-area">
              {loading && (
                <div className="loading-state">
                  <div className="spinner"></div>
                  <p>Searching...</p>
                </div>
              )}

              {!loading && searched && searchMode === 'simple' && simpleResults.length === 0 && (
                <div className="empty-state">
                  <p>No rhymes found for "{query}"</p>
                  <p className="empty-hint">Try a different word or adjust your filters</p>
                </div>
              )}

              {!loading && searchMode === 'simple' && simpleResults.length > 0 && (
                <div className="results-list">
                  <div className="results-header">
                    <h2>{simpleResults.length} results for "{query}"</h2>
                    <label className="toggle-label">
                      <input
                        type="checkbox"
                        checked={onePerSong}
                        onChange={(e) => setOnePerSong(e.target.checked)}
                      />
                      <span>1 result per song</span>
                    </label>
                  </div>
                  {simpleResults.map((result, idx) => (
                    <div key={idx} className="result-card clickable" onClick={() => handleViewLyrics(result.song.id, result.song.title, result.song.artist, [])}>
                      <div className="lyric-context">
                        {result.linesBefore.map((line, i) => (
                          <div key={`before-${i}`} className="context-line">{line}</div>
                        ))}
                        <div className="match-line" dangerouslySetInnerHTML={{
                          __html: result.matchLine.replace(
                            new RegExp(`(${result.word})`, 'gi'),
                            '<strong>$1</strong>'
                          )
                        }} />
                        {result.linesAfter.map((line, i) => (
                          <div key={`after-${i}`} className="context-line">{line}</div>
                        ))}
                      </div>
                      <div className="result-meta">
                        <span className="result-song">
                          {result.song.title} - {result.song.artist}
                        </span>
                        {result.song.year && <span className="result-year">{result.song.year}</span>}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {!loading && searchMode === 'network' && networkResult && sortedResults.length > 0 && (
                <div className="results-list">
                  <div className="results-header">
                    <h2>
                      {sortedResults.length} words for "{networkResult.searchWord}"
                    </h2>
                    <p className="results-meta">
                      {networkResult.totalConnections} connections â€¢ Depth 1-{networkResult.maxDepth}
                    </p>
                  </div>
                  <div className="network-results-grid">
                    {sortedResults.map((result) => (
                      <div key={result.word} className="network-result-card">
                        <div className="network-word">{result.word}</div>
                        <div className="network-meta">
                          <span className={`depth-badge depth-${result.depth}`}>
                            Depth {result.depth}
                          </span>
                          <span className="rhyme-type">{result.rhymeType}</span>
                          <span className="frequency">Ã—{result.frequency}</span>
                        </div>
                        <div className="network-songs">
                          {(expandedWords.has(result.word) ? result.connections : result.connections.slice(0, 2)).map((conn, idx) => (
                            <div 
                              key={idx} 
                              className="network-song clickable"
                              onClick={() => {
                                // Use the full path stored in the connection
                                handleViewLyrics(conn.song.id, conn.song.title, conn.song.artist, conn.path)
                              }}
                            >
                              {conn.song.title} - {conn.song.artist}
                            </div>
                          ))}
                          {result.connections.length > 2 && (
                            <div 
                              className="more-connections clickable"
                              onClick={() => toggleExpanded(result.word)}
                            >
                              {expandedWords.has(result.word) 
                                ? 'Show less' 
                                : `+${result.connections.length - 2} more`
                              }
                            </div>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {!loading && !searched && (
                <div className="empty-state">
                  <h2>ðŸŽµ Search for Rhymes</h2>
                  <p>
                    {searchMode === 'simple' 
                      ? 'Enter a word to find rhyming lines across all songs'
                      : 'Discover rhyme networks across songs at different depths'}
                  </p>
                </div>
              )}
            </div>
          </>
        )}

        {currentPage === 'concepts' && (
          <div className="concepts-page">
            {/* Mode Toggle */}
            <div className="concept-mode-toggle">
              <button 
                className={conceptMode === 'random' ? 'active' : ''}
                onClick={() => setConceptMode('random')}
              >
                Random Concept
              </button>
              <button 
                className={conceptMode === 'custom' ? 'active' : ''}
                onClick={() => setConceptMode('custom')}
              >
                Custom Concept
              </button>
            </div>

            {/* Custom Concept Input */}
            {conceptMode === 'custom' && (
              <div className="custom-concept-builder">
                <div className="concept-input-section">
                  <label>Your Concept Idea:</label>
                  <textarea
                    value={customIdea}
                    onChange={(e) => setCustomIdea(e.target.value)}
                    placeholder="Describe your song concept... (e.g., 'A song about missing your ex but pretending you're over them at a party')"
                    rows={4}
                    className="concept-textarea"
                  />
                </div>

                <div className="concept-matching-section">
                  <h3>Match Songs By Theme</h3>
                  
                  <div className="filter-group">
                    <label>Number of songs:</label>
                    <div className="button-group">
                      {[5, 10, 20].map(num => (
                        <button
                          key={num}
                          className={conceptFilters.numSongs === num ? 'active' : ''}
                          onClick={() => setConceptFilters({...conceptFilters, numSongs: num})}
                        >
                          {num}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Year:</label>
                    <div className="button-group">
                      {['2020s', '2010s', '2000s', '1990s', '1980s'].map(decade => {
                        const years = decade === '2020s' ? [2020, 2021, 2022, 2023, 2024, 2025] :
                                     decade === '2010s' ? [2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019] :
                                     decade === '2000s' ? [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009] :
                                     decade === '1990s' ? [1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999] :
                                     [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989]
                        const isActive = years.some(y => conceptFilters.years.includes(y))
                        return (
                          <button
                            key={decade}
                            className={isActive ? 'active' : ''}
                            onClick={() => {
                              if (isActive) {
                                setConceptFilters({...conceptFilters, years: conceptFilters.years.filter(y => !years.includes(y))})
                              } else {
                                setConceptFilters({...conceptFilters, years: [...conceptFilters.years, ...years]})
                              }
                            }}
                          >
                            {decade}
                          </button>
                        )
                      })}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Chart Position:</label>
                    <div className="button-group">
                      <button
                        className={conceptFilters.maxRank === 10 ? 'active' : ''}
                        onClick={() => setConceptFilters({...conceptFilters, minRank: 1, maxRank: 10})}
                      >
                        Top 10
                      </button>
                      <button
                        className={conceptFilters.maxRank === 20 ? 'active' : ''}
                        onClick={() => setConceptFilters({...conceptFilters, minRank: 1, maxRank: 20})}
                      >
                        Top 20
                      </button>
                      <button
                        className={conceptFilters.maxRank === 50 ? 'active' : ''}
                        onClick={() => setConceptFilters({...conceptFilters, minRank: 1, maxRank: 50})}
                      >
                        Top 50
                      </button>
                      <button
                        className={!conceptFilters.maxRank ? 'active' : ''}
                        onClick={() => setConceptFilters({...conceptFilters, minRank: undefined, maxRank: undefined})}
                      >
                        Any
                      </button>
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Genre:</label>
                    <div className="button-group">
                      {['pop', 'rock', 'hip hop', 'r&b', 'country', 'dance'].map(genre => (
                        <button
                          key={genre}
                          className={conceptFilters.genres.includes(genre) ? 'active' : ''}
                          onClick={() => {
                            if (conceptFilters.genres.includes(genre)) {
                              setConceptFilters({...conceptFilters, genres: conceptFilters.genres.filter(g => g !== genre)})
                            } else {
                              setConceptFilters({...conceptFilters, genres: [...conceptFilters.genres, genre]})
                            }
                          }}
                        >
                          {genre}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Artists (comma separated):</label>
                    <input
                      type="text"
                      placeholder="e.g., Taylor Swift, Ed Sheeran, Adele"
                      value={conceptFilters.artists.join(', ')}
                      onChange={(e) => {
                        const artistList = e.target.value.split(',').map(a => a.trim()).filter(a => a.length > 0)
                        setConceptFilters({...conceptFilters, artists: artistList})
                      }}
                      className="artist-input"
                    />
                  </div>

                  <div className="find-songs-section">
                    <button 
                      onClick={handleFindMatchingSongs} 
                      disabled={conceptLoading || !customIdea.trim()}
                      className="find-songs-btn"
                    >
                      {conceptLoading ? 'Finding Songs...' : 'ðŸ” Find Matching Songs'}
                    </button>
                  </div>
                </div>

                {/* Matched Songs List */}
                {showingSongMatches && (
                  <div className="matched-songs-section">
                    <div className="matched-songs-header">
                      <h3>Matched Songs ({matchedSongs.length})</h3>
                      <p className="matched-songs-subtitle">Review and curate your inspiration songs</p>
                    </div>

                    <div className="matched-songs-list">
                      {matchedSongs.map(song => (
                        <div key={song.id} className="matched-song-card">
                          <div className="song-info">
                            <div className="song-title">{song.title}</div>
                            <div className="song-artist">{song.artist}</div>
                            {song.matchScore !== undefined && (
                              <span 
                                className="match-score clickable"
                                onClick={() => setViewingSongDetails(viewingSongDetails === song.id ? null : song.id)}
                              >
                                {song.matchScore} {song.matchScore === 1 ? 'match' : 'matches'} â€¢ Click to view
                              </span>
                            )}
                            {viewingSongDetails === song.id && (
                              <div className="song-details-popup">
                                <div className="detail-section">
                                  <strong>Themes:</strong>
                                  <div className="theme-tags">
                                    {song.themes?.map((theme, idx) => {
                                      // Check if this theme matches any extracted theme (fuzzy)
                                      const isMatch = extractedThemes.some(extracted => 
                                        theme.toLowerCase().includes(extracted.toLowerCase()) || 
                                        extracted.toLowerCase().includes(theme.toLowerCase())
                                      )
                                      return (
                                        <span key={idx} className={`theme-tag ${isMatch ? 'matched' : ''}`}>
                                          {isMatch && 'âœ¨ '}{theme}
                                        </span>
                                      )
                                    })}
                                  </div>
                                </div>
                                {song.imagery && (
                                  <div className="detail-section">
                                    <strong>Imagery:</strong>
                                    <ul>
                                      {song.imagery.map((img, idx) => <li key={idx}>{img}</li>)}
                                    </ul>
                                  </div>
                                )}
                                {song.tone && (
                                  <div className="detail-section">
                                    <strong>Tone:</strong> {song.tone}
                                  </div>
                                )}
                                {song.universal_scenarios && (
                                  <div className="detail-section">
                                    <strong>Universal Scenarios:</strong>
                                    <ul>
                                      {song.universal_scenarios.map((scenario, idx) => <li key={idx}>{scenario}</li>)}
                                    </ul>
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                          <button 
                            onClick={() => handleRemoveSong(song.id)}
                            className="remove-song-btn"
                          >
                            âœ•
                          </button>
                        </div>
                      ))}
                    </div>

                    <div className="manual-song-search">
                      <label>Add more songs:</label>
                      <input
                        type="text"
                        placeholder="Search by song title or artist..."
                        value={songSearchQuery}
                        onChange={(e) => {
                          setSongSearchQuery(e.target.value)
                          handleSearchSongs(e.target.value)
                        }}
                        className="song-search-input"
                      />
                      {songSearchResults.length > 0 && (
                        <div className="search-results-dropdown">
                          {songSearchResults.map(song => (
                            <div 
                              key={song.id} 
                              className="search-result-item"
                              onClick={() => handleAddSong(song.id)}
                            >
                              <span className="result-title">{song.title}</span>
                              <span className="result-artist">{song.artist}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>

                    <div className="time-estimate">
                      â±ï¸ Estimated time: ~{getEstimatedTime().toFixed(1)} seconds
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Generate Button */}
            <div className="concepts-header">
              {conceptMode === 'custom' && showingSongMatches ? (
                <button 
                  onClick={handleGenerateConcept} 
                  disabled={conceptLoading || matchedSongs.length === 0} 
                  className="search-button"
                >
                  {conceptLoading ? 'Generating...' : `Generate from ${matchedSongs.length} Songs`}
                </button>
              ) : (
                <button 
                  onClick={conceptMode === 'random' ? handleGenerateConcept : handleFindMatchingSongs} 
                  disabled={conceptLoading} 
                  className="search-button"
                >
                  {conceptLoading ? 'Loading...' : conceptMode === 'random' ? 'Generate Random Concept' : 'Find Matching Songs'}
                </button>
              )}
            </div>

            {concept && (
              <div className="concept-display">
                <div className="concept-export-section">
                  <button 
                    onClick={() => {
                      // Download concept as PDF
                      const conceptData = {
                        title: conceptMode === 'random' ? `${concept.songs.title} - ${concept.songs.artist}` : 'Custom Concept',
                        ...concept
                      }
                      
                      fetch('http://localhost:3001/api/export-concept', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(conceptData)
                      })
                      .then(res => res.blob())
                      .then(blob => {
                        const url = window.URL.createObjectURL(blob)
                        const a = document.createElement('a')
                        a.href = url
                        a.download = `concept-${Date.now()}.pdf`
                        a.click()
                      })
                      .catch(err => console.error('Export failed:', err))
                    }}
                    className="export-btn"
                  >
                    ðŸ“„ Export as PDF
                  </button>
                </div>
                {concept.concept_summary && (
                  <div className="concept-section">
                    <h3>Summary</h3>
                    <p className="concept-summary">{concept.concept_summary}</p>
                  </div>
                )}

                <div className="concept-section">
                  <h3>Themes</h3>
                  <div className="theme-tags">
                    {concept.themes.map((theme, idx) => (
                      <span key={idx} className="theme-tag">{theme}</span>
                    ))}
                  </div>
                </div>

                {concept.imagery && concept.imagery.length > 0 && (
                  <div className="concept-section">
                    <h3>Imagery</h3>
                    <div className="imagery-list">
                      {concept.imagery.map((img, idx) => (
                        <div key={idx} className="imagery-item">{img}</div>
                      ))}
                    </div>
                  </div>
                )}

                {concept.tone && (
                  <div className="concept-section">
                    <h3>Tone</h3>
                    <p className="tone-text">{concept.tone}</p>
                  </div>
                )}

                {concept.universal_scenarios && concept.universal_scenarios.length > 0 && (
                  <div className="concept-section">
                    <h3>Universal Scenarios</h3>
                    <div className="scenarios-list">
                      {concept.universal_scenarios.map((scenario, idx) => (
                        <div key={idx} className="scenario-item">â€¢ {scenario}</div>
                      ))}
                    </div>
                  </div>
                )}

                {titles.length > 0 && (
                  <div className="concept-section">
                    <h3>Alternative Titles</h3>
                    <div className="titles-grid">
                      {titles.map((title, idx) => (
                        <div key={idx} className="title-card">{title}</div>
                      ))}
                    </div>
                    <div className="more-titles-section">
                      <button 
                        onClick={handleGenerateMoreTitles}
                        disabled={generatingTitles}
                        className="more-titles-btn"
                      >
                        {generatingTitles ? 'Generating...' : 'âœ¨ Generate More Titles'}
                      </button>
                    </div>
                  </div>
                )}

                {concept.section_breakdown && concept.section_breakdown.length > 0 && (
                  <div className="concept-section">
                    <h3>Section Breakdown</h3>
                    <div className="section-breakdown">
                      {concept.section_breakdown.map((section, idx) => (
                        <div key={idx} className="section-item">{section}</div>
                      ))}
                    </div>
                  </div>
                )}

                {concept.thematic_vocabulary && concept.thematic_vocabulary.length > 0 && (
                  <div className="concept-section">
                    <h3>Thematic Vocabulary</h3>
                    <div className="vocab-tags">
                      {concept.thematic_vocabulary.map((word, idx) => (
                        <span key={idx} className="vocab-tag">{word}</span>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        {/* Next Line Page */}
        {currentPage === 'nextline' && (
          <div className="nextline-page">
            <div className="nextline-header">
              <h1>AI Songwriting Assistant</h1>
              <p className="nextline-subtitle">Get AI-powered suggestions for your next line</p>
            </div>

            <div className="nextline-builder">
              <div className="nextline-inputs">
                <div className="input-section">
                  <label>Song Concept/Theme</label>
                  <textarea
                    value={nextLineConcept}
                    onChange={(e) => setNextLineConcept(e.target.value)}
                    placeholder="What's your song about? (e.g., 'A song about missing your ex but pretending you're over them')"
                    rows={3}
                    className="nextline-textarea"
                  />
                </div>

                <div className="input-section">
                  <label>Lyrics You've Written So Far</label>
                  <textarea
                    value={existingLyrics}
                    onChange={(e) => setExistingLyrics(e.target.value)}
                    placeholder="Paste your existing lyrics here (optional but recommended for better context)"
                    rows={8}
                    className="nextline-textarea"
                  />
                </div>

                <div className="input-row">
                  <div className="input-section flex-1">
                    <label>Example Line (syllable pattern)</label>
                    <input
                      type="text"
                      value={exampleLine}
                      onChange={(e) => setExampleLine(e.target.value)}
                      placeholder="e.g., 'I've been thinking about you lately'"
                      className="nextline-input"
                    />
                    {exampleLine && (
                      <div className="syllable-count">
                        Syllables: {countSyllables(exampleLine)}
                      </div>
                    )}
                  </div>
                </div>

                <div className="input-row">
                  <div className="input-section flex-1">
                    <label>Rhyme With (word/sound)</label>
                    <input
                      type="text"
                      value={rhymeTarget}
                      onChange={(e) => setRhymeTarget(e.target.value)}
                      placeholder="e.g., 'you'"
                      className="nextline-input"
                    />
                  </div>

                  <div className="input-section">
                    <label>Position</label>
                    <select 
                      value={rhymePosition} 
                      onChange={(e) => setRhymePosition(e.target.value as 'end' | 'internal')}
                      className="nextline-select"
                    >
                      <option value="end">End of line</option>
                      <option value="internal">Internal</option>
                    </select>
                  </div>

                  <div className="input-section">
                    <label>Rhyme Type</label>
                    <select 
                      value={rhymeTypeFilter} 
                      onChange={(e) => setRhymeTypeFilter(e.target.value)}
                      className="nextline-select"
                    >
                      <option value="any">Any</option>
                      <option value="perfect">Perfect</option>
                      <option value="slant">Slant</option>
                      <option value="assonance">Assonance</option>
                      <option value="consonance">Consonance</option>
                    </select>
                  </div>

                  <div className="input-section">
                    <label>Line Type</label>
                    <select 
                      value={lineType} 
                      onChange={(e) => setLineType(e.target.value as 'regular' | 'metaphor' | 'simile')}
                      className="nextline-select"
                    >
                      <option value="regular">Regular Line</option>
                      <option value="metaphor">Metaphor</option>
                      <option value="simile">Simile</option>
                    </select>
                  </div>
                </div>

                {/* Optional constraints */}
                <div className="input-section">
                  <label>What Should This Line Mean? (optional)</label>
                  <input
                    type="text"
                    value={lineMeaning}
                    onChange={(e) => setLineMeaning(e.target.value)}
                    placeholder="e.g., 'Expressing regret for mistakes made'"
                    className="nextline-input"
                  />
                </div>

                <div className="input-row">
                  <div className="input-section flex-1">
                    <label>Use This Specific Rhyme Word (optional)</label>
                    <input
                      type="text"
                      value={specificRhymeWord}
                      onChange={(e) => setSpecificRhymeWord(e.target.value)}
                      placeholder="e.g., 'blue' (will force this exact rhyme word)"
                      className="nextline-input"
                    />
                  </div>

                  <div className="input-section flex-1">
                    <label>Partial Line Already Written (optional)</label>
                    <input
                      type="text"
                      value={partialLine}
                      onChange={(e) => setPartialLine(e.target.value)}
                      placeholder="e.g., 'I know that' (AI will complete this)"
                      className="nextline-input"
                    />
                  </div>
                </div>

                {/* Filters */}
                <div className="nextline-filters">
                  <h3>Filter Reference Songs</h3>
                  
                  <div className="filter-group">
                    <label>Number of songs:</label>
                    <div className="button-group">
                      {[5, 10, 20].map(num => (
                        <button
                          key={num}
                          className={nextLineFilters.numSongs === num ? 'active' : ''}
                          onClick={() => setNextLineFilters({...nextLineFilters, numSongs: num})}
                        >
                          {num}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Year:</label>
                    <div className="button-group">
                      {['2020s', '2010s', '2000s', '1990s', '1980s'].map(decade => {
                        const years = decade === '2020s' ? [2020, 2021, 2022, 2023, 2024, 2025] :
                                     decade === '2010s' ? [2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019] :
                                     decade === '2000s' ? [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009] :
                                     decade === '1990s' ? [1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999] :
                                     [1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989]
                        const isActive = years.some(y => nextLineFilters.years.includes(y))
                        return (
                          <button
                            key={decade}
                            className={isActive ? 'active' : ''}
                            onClick={() => {
                              if (isActive) {
                                setNextLineFilters({...nextLineFilters, years: nextLineFilters.years.filter(y => !years.includes(y))})
                              } else {
                                setNextLineFilters({...nextLineFilters, years: [...nextLineFilters.years, ...years]})
                              }
                            }}
                          >
                            {decade}
                          </button>
                        )
                      })}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Chart Position:</label>
                    <div className="button-group">
                      <button
                        className={nextLineFilters.maxRank === 10 ? 'active' : ''}
                        onClick={() => setNextLineFilters({...nextLineFilters, minRank: 1, maxRank: 10})}
                      >
                        Top 10
                      </button>
                      <button
                        className={nextLineFilters.maxRank === 20 ? 'active' : ''}
                        onClick={() => setNextLineFilters({...nextLineFilters, minRank: 1, maxRank: 20})}
                      >
                        Top 20
                      </button>
                      <button
                        className={nextLineFilters.maxRank === 50 ? 'active' : ''}
                        onClick={() => setNextLineFilters({...nextLineFilters, minRank: 1, maxRank: 50})}
                      >
                        Top 50
                      </button>
                      <button
                        className={!nextLineFilters.maxRank ? 'active' : ''}
                        onClick={() => setNextLineFilters({...nextLineFilters, minRank: undefined, maxRank: undefined})}
                      >
                        Any
                      </button>
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Genre:</label>
                    <div className="button-group">
                      {['pop', 'rock', 'hip hop', 'r&b', 'country', 'dance'].map(genre => (
                        <button
                          key={genre}
                          className={nextLineFilters.genres.includes(genre) ? 'active' : ''}
                          onClick={() => {
                            if (nextLineFilters.genres.includes(genre)) {
                              setNextLineFilters({...nextLineFilters, genres: nextLineFilters.genres.filter(g => g !== genre)})
                            } else {
                              setNextLineFilters({...nextLineFilters, genres: [...nextLineFilters.genres, genre]})
                            }
                          }}
                        >
                          {genre}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Artists (comma separated):</label>
                    <input
                      type="text"
                      placeholder="e.g., Taylor Swift, Ed Sheeran"
                      value={nextLineFilters.artists.join(', ')}
                      onChange={(e) => {
                        const artistList = e.target.value.split(',').map(a => a.trim()).filter(a => a.length > 0)
                        setNextLineFilters({...nextLineFilters, artists: artistList})
                      }}
                      className="artist-input"
                    />
                  </div>
                </div>

                <div className="nextline-actions">
                  <button 
                    onClick={handleFindNextLineSongs}
                    disabled={generatingNextLine || !nextLineConcept.trim()}
                    className="search-button"
                  >
                    ðŸ” Find Reference Songs
                  </button>
                </div>
              </div>

              {/* Matched Songs for Next Line */}
              {showingNextLineSongs && nextLineMatchedSongs.length > 0 && (
                <div className="matched-songs-section">
                  <div className="matched-songs-header">
                    <h3>Reference Songs ({nextLineMatchedSongs.length})</h3>
                    <p className="matched-songs-subtitle">These songs will guide the AI's suggestions</p>
                  </div>

                  <div className="matched-songs-list">
                    {nextLineMatchedSongs.map(song => (
                      <div key={song.id} className="matched-song-card">
                        <div className="song-info">
                          <div className="song-title">{song.title}</div>
                          <div className="song-artist">{song.artist}</div>
                          {song.matchScore !== undefined && (
                            <span 
                              className="match-score clickable"
                              onClick={() => setViewingNextLineSongDetails(viewingNextLineSongDetails === song.id ? null : song.id)}
                            >
                              {song.matchScore} {song.matchScore === 1 ? 'match' : 'matches'} â€¢ Click to view
                            </span>
                          )}
                          {viewingNextLineSongDetails === song.id && (
                            <div className="song-details-popup">
                              <div className="detail-section">
                                <strong>Themes:</strong>
                                <div className="theme-tags">
                                  {song.themes?.map((theme, idx) => {
                                    // Check if this theme matches any extracted theme (fuzzy)
                                    const isMatch = nextLineExtractedThemes.some(extracted => 
                                      theme.toLowerCase().includes(extracted.toLowerCase()) || 
                                      extracted.toLowerCase().includes(theme.toLowerCase())
                                    )
                                    return (
                                      <span key={idx} className={`theme-tag ${isMatch ? 'matched' : ''}`}>
                                        {isMatch && 'âœ¨ '}{theme}
                                      </span>
                                    )
                                  })}
                                </div>
                              </div>
                              {song.imagery && (
                                <div className="detail-section">
                                  <strong>Imagery:</strong>
                                  <ul>
                                    {song.imagery.map((img, idx) => <li key={idx}>{img}</li>)}
                                  </ul>
                                </div>
                              )}
                              {song.tone && (
                                <div className="detail-section">
                                  <strong>Tone:</strong> {song.tone}
                                </div>
                              )}
                              {song.universal_scenarios && (
                                <div className="detail-section">
                                  <strong>Universal Scenarios:</strong>
                                  <ul>
                                    {song.universal_scenarios.map((scenario, idx) => <li key={idx}>{scenario}</li>)}
                                  </ul>
                                </div>
                              )}
                            </div>
                          )}
                        </div>
                        <button 
                          onClick={() => setNextLineMatchedSongs(nextLineMatchedSongs.filter(s => s.id !== song.id))}
                          className="remove-song-btn"
                        >
                          âœ•
                        </button>
                      </div>
                    ))}
                  </div>

                  <div className="nextline-actions">
                    <button 
                      onClick={handleGenerateNextLine}
                      disabled={generatingNextLine || nextLineMatchedSongs.length === 0}
                      className="search-button"
                    >
                      {generatingNextLine ? 'Generating...' : 'âœ¨ Generate Line Suggestions'}
                    </button>
                  </div>
                </div>
              )}

              {/* Suggestions */}
              {nextLineSuggestions.length > 0 && (
                <div className="suggestions-section">
                  <h3>Suggested Next Lines ({nextLineSuggestions.length})</h3>
                  <div className="suggestions-list">
                    {nextLineSuggestions.map((suggestion, idx) => (
                      <div key={idx} className={`suggestion-card ${suggestion.diff === 0 ? 'perfect-match' : ''}`}>
                        <div className="suggestion-header">
                          <div className="suggestion-text">{suggestion.line}</div>
                          <div className={`syllable-badge ${suggestion.diff === 0 ? 'exact' : suggestion.diff <= 1 ? 'close' : 'far'}`}>
                            {suggestion.syllables} syl {suggestion.diff === 0 ? 'âœ…' : ''}
                          </div>
                        </div>
                        <div className="suggestion-actions">
                          <button 
                            onClick={() => handleMoreLikeThis(suggestion.line)}
                            disabled={generatingNextLine}
                            className="more-like-btn"
                          >
                            More Like This
                          </button>
                          <button 
                            onClick={() => handleUseSuggestion(suggestion.line)}
                            className="use-btn"
                          >
                            Use This
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="nextline-actions">
                    <button 
                      onClick={handleGenerateNextLine}
                      disabled={generatingNextLine}
                      className="more-titles-btn"
                    >
                      {generatingNextLine ? 'Generating...' : 'âœ¨ Generate More Variations'}
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {currentPage === 'figurative' && (
          <div className="figurative-page">
            <div className="figurative-header">
              <h1>Figurative Language Finder</h1>
              <p className="figurative-subtitle">Search for similes, metaphors, and other figurative language patterns in hit songs</p>
            </div>

            <div className="figurative-content">
              {/* Keyword Selection */}
              <div className="keyword-section">
                <h3>Search for lines containing:</h3>
                
                <div className="keyword-presets">
                  <div className="preset-group">
                    <span className="preset-label">Similes:</span>
                    <div className="preset-buttons">
                      {['like', 'as', 'than'].map(kw => (
                        <button
                          key={kw}
                          className={`keyword-btn ${figurativeKeywords.includes(kw) ? 'active' : ''}`}
                          onClick={() => {
                            if (figurativeKeywords.includes(kw)) {
                              setFigurativeKeywords(figurativeKeywords.filter(k => k !== kw))
                            } else {
                              setFigurativeKeywords([...figurativeKeywords, kw])
                            }
                          }}
                        >
                          "{kw}"
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="preset-group">
                    <span className="preset-label">Metaphors:</span>
                    <div className="preset-buttons">
                      {['is a', 'is the', 'was a', 'are the', 'am a'].map(kw => (
                        <button
                          key={kw}
                          className={`keyword-btn ${figurativeKeywords.includes(kw) ? 'active' : ''}`}
                          onClick={() => {
                            if (figurativeKeywords.includes(kw)) {
                              setFigurativeKeywords(figurativeKeywords.filter(k => k !== kw))
                            } else {
                              setFigurativeKeywords([...figurativeKeywords, kw])
                            }
                          }}
                        >
                          "{kw}"
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="preset-group">
                    <span className="preset-label">Custom:</span>
                    <div className="custom-keyword-input">
                      <input
                        type="text"
                        value={figurativeCustomKeyword}
                        onChange={(e) => setFigurativeCustomKeyword(e.target.value)}
                        placeholder="Enter custom keyword..."
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && figurativeCustomKeyword.trim()) {
                            setFigurativeKeywords([...figurativeKeywords, figurativeCustomKeyword.trim()])
                            setFigurativeCustomKeyword('')
                          }
                        }}
                      />
                      <button
                        onClick={() => {
                          if (figurativeCustomKeyword.trim()) {
                            setFigurativeKeywords([...figurativeKeywords, figurativeCustomKeyword.trim()])
                            setFigurativeCustomKeyword('')
                          }
                        }}
                      >
                        Add
                      </button>
                    </div>
                  </div>
                </div>

                <div className="active-keywords">
                  <span>Searching for: </span>
                  {figurativeKeywords.map(kw => (
                    <span key={kw} className="keyword-tag">
                      "{kw}"
                      <button onClick={() => setFigurativeKeywords(figurativeKeywords.filter(k => k !== kw))}>Ã—</button>
                    </span>
                  ))}
                </div>
              </div>

              {/* Filters */}
              <div className="figurative-filters">
                <h3>Filters (optional)</h3>
                <div className="filter-row">
                  <div className="filter-group">
                    <label>Chart Position:</label>
                    <div className="button-group">
                      <button
                        className={figurativeFilters.minRank === 1 && figurativeFilters.maxRank === 10 ? 'active' : ''}
                        onClick={() => setFigurativeFilters({...figurativeFilters, minRank: 1, maxRank: 10})}
                      >
                        Top 10
                      </button>
                      <button
                        className={figurativeFilters.minRank === 1 && figurativeFilters.maxRank === 20 ? 'active' : ''}
                        onClick={() => setFigurativeFilters({...figurativeFilters, minRank: 1, maxRank: 20})}
                      >
                        Top 20
                      </button>
                      <button
                        className={figurativeFilters.minRank === undefined ? 'active' : ''}
                        onClick={() => setFigurativeFilters({...figurativeFilters, minRank: undefined, maxRank: undefined})}
                      >
                        Any
                      </button>
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Decade:</label>
                    <div className="button-group">
                      {['2020s', '2010s', '2000s'].map(decade => {
                        const years = decade === '2020s' ? [2020, 2021, 2022, 2023, 2024, 2025] :
                                     decade === '2010s' ? [2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019] :
                                     [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009]
                        const isActive = years.some(y => figurativeFilters.years.includes(y))
                        return (
                          <button
                            key={decade}
                            className={isActive ? 'active' : ''}
                            onClick={() => {
                              if (isActive) {
                                setFigurativeFilters({...figurativeFilters, years: figurativeFilters.years.filter(y => !years.includes(y))})
                              } else {
                                setFigurativeFilters({...figurativeFilters, years: [...figurativeFilters.years, ...years]})
                              }
                            }}
                          >
                            {decade}
                          </button>
                        )
                      })}
                    </div>
                  </div>

                  <div className="filter-group">
                    <label>Genre:</label>
                    <div className="button-group">
                      {['pop', 'rock', 'hip hop', 'r&b', 'country'].map(genre => (
                        <button
                          key={genre}
                          className={figurativeFilters.genres.includes(genre) ? 'active' : ''}
                          onClick={() => {
                            if (figurativeFilters.genres.includes(genre)) {
                              setFigurativeFilters({...figurativeFilters, genres: figurativeFilters.genres.filter(g => g !== genre)})
                            } else {
                              setFigurativeFilters({...figurativeFilters, genres: [...figurativeFilters.genres, genre]})
                            }
                          }}
                        >
                          {genre}
                        </button>
                      ))}
                    </div>
                  </div>
                </div>
              </div>

              {/* Search Button */}
              <button 
                className="search-button"
                onClick={handleFigurativeSearch}
                disabled={figurativeSearching || figurativeKeywords.length === 0}
              >
                {figurativeSearching ? 'Searching...' : `ðŸ” Search for ${figurativeKeywords.map(k => '"' + k + '"').join(', ')}`}
              </button>

              {/* Results */}
              {figurativeResults.length > 0 && (
                <div className="figurative-results">
                  <h3>Found {figurativeResults.length} results</h3>
                  <div className="results-grid">
                    {figurativeResults.map((result, idx) => (
                      <div key={idx} className="figurative-result-card">
                        <div className="result-song-info">
                          <strong>{result.songTitle}</strong> - {result.artist}
                        </div>
                        <div className="result-context">
                          {result.context.map((line, lineIdx) => {
                            const isMatchLine = line === result.line
                            if (isMatchLine) {
                              // Highlight the keyword in the matched line
                              const keywordLower = result.keyword.toLowerCase()
                              const lineLower = line.toLowerCase()
                              const keywordIdx = lineLower.indexOf(keywordLower)
                              if (keywordIdx !== -1) {
                                return (
                                  <div key={lineIdx} className="context-line matched">
                                    {line.slice(0, keywordIdx)}
                                    <span className="keyword-highlight">{line.slice(keywordIdx, keywordIdx + result.keyword.length)}</span>
                                    {line.slice(keywordIdx + result.keyword.length)}
                                  </div>
                                )
                              }
                            }
                            return <div key={lineIdx} className={`context-line ${isMatchLine ? 'matched' : ''}`}>{line}</div>
                          })}
                        </div>
                        <div className="result-actions">
                          <button 
                            className="view-song-btn"
                            onClick={() => handleViewLyrics(result.songId, result.keyword)}
                          >
                            View Full Song
                          </button>
                          <div className="generate-variation">
                            <input
                              type="text"
                              placeholder="Enter meaning..."
                              value={figurativeMeaning}
                              onChange={(e) => setFigurativeMeaning(e.target.value)}
                            />
                            <button
                              onClick={() => handleGenerateFigurativeVariations(result.line, result.keyword)}
                              disabled={figurativeGenerating}
                            >
                              {figurativeGenerating ? '...' : 'âœ¨ Generate with this meaning'}
                            </button>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {figurativeResults.length === 0 && !figurativeSearching && figurativeKeywords.length > 0 && (
                <div className="no-results">
                  <p>Click search to find figurative language patterns in songs</p>
                </div>
              )}
            </div>
          </div>
        )}
      </main>

      {/* Filter Sidebar */}
      <FilterSidebar 
        isOpen={filterSidebarOpen}
        onClose={() => setFilterSidebarOpen(false)}
        filters={filters}
        onChange={setFilters}
        mode={searchMode}
      />

      {/* Lyrics Modal */}
      {showLyricsModal && (
        <div className="modal-overlay" onClick={() => setShowLyricsModal(false)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>{modalSongTitle}</h2>
              <div className="modal-actions">
                {modalHighlightWords.length > 0 && (
                  <button 
                    className="view-toggle-btn"
                    onClick={() => setModalViewMode(modalViewMode === 'context' ? 'full' : 'context')}
                  >
                    {modalViewMode === 'context' ? 'View Full Song' : 'View in Context'}
                  </button>
                )}
                <button className="modal-close" onClick={() => setShowLyricsModal(false)}>Ã—</button>
              </div>
            </div>
            <div className="modal-body">
              {/* Show rhyme path if in context mode and we have multiple words */}
              {modalViewMode === 'context' && modalHighlightWords.length > 1 && (
                <div className="rhyme-path">
                  {modalHighlightWords.map((word, idx) => (
                    <span key={idx}>
                      {idx > 0 && <span className="path-arrow"> â†’ </span>}
                      <span className="path-word">{word}</span>
                    </span>
                  ))}
                </div>
              )}
              
              {modalViewMode === 'full' ? (
                <pre className="lyrics-display" dangerouslySetInnerHTML={{ 
                  __html: modalHighlightWords.length > 0
                    ? modalHighlightWords.reduce((text, word) => {
                        return text.replace(
                          new RegExp(`\\b(${word})\\b`, 'gi'),
                          '<strong>$1</strong>'
                        )
                      }, modalLyrics)
                    : modalLyrics
                }} />
              ) : (
                <div className="context-view">
                  {modalHighlightWords.length > 0 && getContextView(modalLyrics, modalHighlightWords).map((ctx, idx) => {
                    // Highlight all words in the chain
                    let highlightedLine = ctx.matchLine
                    modalHighlightWords.forEach(word => {
                      highlightedLine = highlightedLine.replace(
                        new RegExp(`\\b(${word})\\b`, 'gi'),
                        '<strong>$1</strong>'
                      )
                    })
                    
                    return (
                      <div key={idx} className="context-block">
                        {ctx.linesBefore.map((line, i) => (
                          <div key={`before-${i}`} className="context-line">{line}</div>
                        ))}
                        <div className="match-line" dangerouslySetInnerHTML={{ __html: highlightedLine }} />
                        {ctx.linesAfter.map((line, i) => (
                          <div key={`after-${i}`} className="context-line">{line}</div>
                        ))}
                        <div className="context-divider" />
                      </div>
                    )
                  })}
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default App
